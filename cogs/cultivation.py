import discord
import random
import asyncio
import json
import time
from datetime import datetime, timedelta
from discord import app_commands, Color
from discord.ext import commands, tasks
from core.helpers import VN_TZ, ask_ancestor, get_rank_info, txa_embed, number_to_emoji, get_all_rank_names, rainbow_log
from core.format import TXAFormat
from core.database import Database
from core.game_data import CultivationData
from core.roles_config import RoleConfig
from core.combat import CombatSystem

class Cultivation(commands.Cog):
    NARRATIVE_STAGES = [
        (0, "ğŸŒ€ Báº¯t Ä‘áº§u váº­n chuyá»ƒn linh khÃ­, tÃ¢m tháº§n dáº§n nháº­p Ä‘á»‹nh..."),
        (20, "âš¡ Linh lá»±c cuá»™n trÃ o trong kinh máº¡ch, má»“ hÃ´i báº¯t Ä‘áº§u tháº¥m Ä‘áº«m..."),
        (40, "ğŸ”¥ Äáº¡o lá»±c bÃ¹ng phÃ¡t mÃ£nh liá»‡t, Ä‘ang cá»‘ gáº¯ng cháº¿ ngá»± kÃ¬nh lá»±c..."),
        (60, "ğŸŒŠ KhÃ­ háº£i dÃ¢ng trÃ o, thiÃªn Ä‘á»‹a linh khÃ­ Ä‘ang há»™i tá»¥ vá» cÆ¡ thá»ƒ..."),
        (80, "ğŸ’ Gáº§n nhÆ° cháº¡m tá»›i ngÆ°á»¡ng cá»­a viÃªn mÃ£n, Ä‘áº¡o tÃ¢m kiÃªn Ä‘á»‹nh tuyá»‡t Ä‘á»‘i!"),
        (95, "âœ¨ Linh quang lÃ³e sÃ¡ng! BÃ­ phÃ¡p Ä‘Ã£ hoÃ n thÃ nh 9 pháº§n, chá»‰ cÃ²n chÃºt hÆ¡i sá»©c cuá»‘i..."),
    ]

    def __init__(self, bot):
        self.bot = bot
        self.db: Database = bot.db
        self.active_missions = {}
        self.battling_users = set()

    async def check_auto_role(self, member: discord.Member, layer: int):
        """Tá»± Ä‘á»™ng cáº­p nháº­t Role vÃ  Nickname dá»±a trÃªn cáº£nh giá»›i"""
        rank_name, rank_info = get_rank_info(layer)
        role_data = RoleConfig.get_role_data(rank_name)
        
        # 1. Update Nickname (Prefix)
        # Äáº·c biá»‡t cho Admin
        is_super = member.id == getattr(self.bot, 'super_admin_id', None)
        is_admin = member.id in getattr(self.bot, 'admin_ids', [])
        
        if is_super:
            prefix = "[ChÆ°á»Ÿng MÃ´n]"
        elif is_admin:
            prefix = "[Tá»• SÆ°]"
        else:
            prefix = f"[{rank_name}]"
            
        new_nick = member.display_name
        
        # Remove old prefix if exists
        import re
        new_nick = re.sub(r"^\[.*?\]\s*", "", new_nick) 
        new_nick = f"{prefix} {new_nick}"
        
        if len(new_nick) <= 32:
            try:
                if member.display_name != new_nick:
                    # Note: Váº«n sáº½ fail náº¿u lÃ  Guild Owner mÃ  bot khÃ´ng Ä‘á»§ quyá»n, 
                    # nhÆ°ng try-except sáº½ báº¯t lá»—i nÃ y.
                    await member.edit(nick=new_nick)
            except: 
                pass
            
        # 2. Update Roles
        guild = member.guild
        if not guild: return
        current_roles = member.roles
        target_role_name = rank_name
        
        # Find or create role
        target_role = discord.utils.get(guild.roles, name=target_role_name)
        if not target_role:
             try:
                 permissions = discord.Permissions.none()
                 # Apply CUMULATIVE permissions from config (inherit from lower ranks)
                 perm_dict = RoleConfig.get_cumulative_permissions(rank_name)
                 if perm_dict:
                    permissions.update(**perm_dict)
                 
                 target_role = await guild.create_role(
                     name=target_role_name, 
                     color=discord.Color(role_data['color']), 
                     hoist=True, # Show separately
                     permissions=permissions,
                     mentionable=False,
                     reason="Auto-generated by Cultivation Bot"
                 )
             except Exception as e: 
                 rainbow_log(f"Role create error: {e}")
                 pass
        
        if target_role:
            # LuÃ´n kiá»ƒm tra vÃ  dá»n dáº¹p cÃ¡c role cáº£nh giá»›i cÅ© Ä‘á»ƒ trÃ¡nh bá»‹ trÃ¹ng láº·p role (nhÆ° hÃ¬nh Ä‘á»‡ tá»­ gá»­i)
            all_rank_roles = RoleConfig.get_all_roles().keys()
            to_remove = [r for r in current_roles if r.name in all_rank_roles and r.name != target_role_name]
            
            try:
                if to_remove:
                    await member.remove_roles(*to_remove)
                    rainbow_log(f"  [æ¸…ç†] ÄÃ£ táº©y bá» {len(to_remove)} role cÅ© cho {member.display_name}")
                
                if target_role not in current_roles:
                    await member.add_roles(target_role)
                    rainbow_log(f"  [æ™‹å‡] ÄÃ£ ban sáº¯c phong {target_role_name} cho {member.display_name}")
            except Exception as e:
                # rainbow_log(f"Role sync error: {e}")
                pass

    async def check_daily_xp_limit(self, user_data, exp_to_add):
        """Kiá»ƒm tra giá»›i háº¡n XP hÃ ng ngÃ y"""
        rank_name, _ = get_rank_info(user_data['layer'])
        role_config = RoleConfig.get_role_data(rank_name)
        limit = role_config.get('daily_xp_limit', 1000)
        
        current_daily = user_data.get('daily_exp', 0)
        
        if current_daily + exp_to_add > limit:
            return False, limit
        return True, limit

    async def update_member_visuals(self, member: discord.Member, layer: int):
        """Update nickname and role based on layer - Táº­n dá»¥ng role cÅ© náº¿u cÃ³"""
        # This method is now largely superseded by check_auto_role, but kept for compatibility
        # or if specific logic is needed here. For now, it will call check_auto_role.
        await self.check_auto_role(member, layer)

        # --- Gá»­i DM chÃºc má»«ng (TrÃ¡nh gá»­i láº·p náº¿u layer má»›i cáº­p nháº­t liÃªn tá»¥c) ---
        if layer > 1:
            rank_name, rank_info = get_rank_info(layer)
            try:
                embed = txa_embed(
                    "ğŸ”¥ Äá»™t PhÃ¡ Cáº£nh Giá»›i!",
                    f"ChÃºc má»«ng Ä‘áº¡o há»¯u **{member.display_name}**!\n"
                    f"NgÆ°Æ¡i Ä‘Ã£ thÃ nh cÃ´ng Ä‘á»™t phÃ¡ linh máº¡ch, Ä‘áº¡t tá»›i: **{rank_name} (Táº§ng {layer})**.\n\n"
                    f"PhÃ¡p vá»‹ cá»§a ngÆ°Æ¡i táº¡i ThiÃªn Lam TÃ´ng Ä‘Ã£ Ä‘Æ°á»£c sáº¯c phong: `{rank_name}`.",
                    rank_info['color']
                )
                embed.set_footer(text="ThiÃªn Äáº¡o ghi danh - TÆ°Æ¡ng lai rá»™ng má»Ÿ!")
                await member.send(embed=embed)
            except: pass

    @tasks.loop(hours=1)
    async def spirit_stone_buff_task(self):
        """Buff x3 Linh Tháº¡ch ngáº«u nhiÃªn má»—i giá»"""
        users = await self.db.get_all_users()
        if not users: return
        
        # Chá»n ngáº«u nhiÃªn 3 ngÆ°á»i may máº¯n (hoáº·c 10% user)
        lucky_count = max(1, len(users) // 10)
        lucky_users = random.sample(users, min(len(users), lucky_count))
        
        now = time.time()
        expiry = now + 3600 # 1 tiáº¿ng
        
        for u in lucky_users:
            buffs = u.get('buffs', {})
            buffs['stone_x3'] = expiry
            await self.db.update_user(u['user_id'], buffs=buffs)
            
            # ThÃ´ng bÃ¡o náº¿u cÃ³ thá»ƒ
            try:
                user_obj = await self.bot.fetch_user(int(u['user_id']))
                embed = txa_embed(
                    "âœ¨ THIÃŠN Äáº O CHIáº¾U Cá»", 
                    "NgÆ°Æ¡i Ä‘Ã£ Ä‘Æ°á»£c nháº­n **HÃ o Quang ThÃ¡i DÆ°Æ¡ng**, x3 Linh Tháº¡ch nháº­n Ä‘Æ°á»£c trong 1 giá» tá»›i!", 
                    discord.Color.gold()
                )
                await user_obj.send(embed=embed)
                rainbow_log(f"ğŸŒ [ThiÃªn Äáº¡o] ÄÃ£ ban buff x3 Linh Tháº¡ch cho Ä‘áº¡o há»¯u {u['name']} ({u['user_id']}).")
            except: 
                rainbow_log(f"ğŸŒ [ThiÃªn Äáº¡o] ÄÃ£ ban buff x3 Linh Tháº¡ch cho {u['name']} (KhÃ´ng thá»ƒ gá»­i DM).")

    @spirit_stone_buff_task.before_loop
    async def before_spirit_stone_buff(self):
        await self.bot.wait_until_ready()

    @tasks.loop(hours=1)
    async def daily_reminder_task(self):
        """Gá»­i nháº¯c nhá»Ÿ Ä‘iá»ƒm danh vÃ o 6h sÃ¡ng (trÆ°á»›c reset 1h)"""
        now = datetime.now(VN_TZ)
        if now.hour != 6: return
        
        users = await self.db.get_all_users()
        today_reset = now.replace(hour=7, minute=0, second=0, microsecond=0)
        today_date = (now - timedelta(hours=7)).strftime("%Y-%m-%d")
        
        portal_url = None
        target_guild = None
        if self.bot.allowed_guilds:
            target_guild = self.bot.get_guild(self.bot.allowed_guilds[0].id)

        if target_guild:
            if self.bot.allowed_channel_ids:
                portal_url = f"https://discord.com/channels/{target_guild.id}/{self.bot.allowed_channel_ids[0]}"
            else:
                target_channels = [
                    c for c in target_guild.text_channels 
                    if c.id != self.bot.report_channel_id and c.permissions_for(target_guild.me).send_messages
                ]
                if target_channels:
                    random_channel = random.choice(target_channels)
                    portal_url = f"https://discord.com/channels/{target_guild.id}/{random_channel.id}"

        for u_data in users:
            if u_data['last_daily_date'] != today_date:
                user = self.bot.get_user(int(u_data['user_id']))
                if not user: continue
                
                streak_emoji = number_to_emoji(u_data['daily_streak'])
                timestamp = int(today_reset.timestamp())
                
                embed = txa_embed("â° Nháº¯c Nhá»Ÿ Äiá»ƒm Danh", "", Color.orange())
                embed.description = (
                    f"ğŸ”¥ **Chuá»—i Ä‘iá»ƒm danh hiá»‡n táº¡i:** {streak_emoji} ngÃ y\n"
                    f"âš ï¸ **CÃ²n 1 giá» ná»¯a lÃ  reset!** (<t:{timestamp}:t>)\n\n"
                    f"ğŸ’¡ HÃ£y dÃ¹ng `/daily` ngay Ä‘á»ƒ giá»¯ chuá»—i streak!\n"
                    f"ğŸ“ˆ Streak cÃ ng cao, pháº§n thÆ°á»Ÿng cÃ ng lá»›n!"
                )
                embed.add_field(name="ğŸŒ€ Cá»•ng Dá»‹ch Chuyá»ƒn", value="Nháº¥n nÃºt bÃªn dÆ°á»›i Ä‘á»ƒ trá»Ÿ vá» ThiÃªn Lam TÃ´ng", inline=False)
                time_now = TXAFormat.time(now.hour * 3600 + now.minute * 60 + now.second)
                embed.set_footer(text=f"PhÃ¡p thá»i: {time_now} - THIEN-LAM-LIVE-AI BY TXA!")
                
                view = discord.ui.View()
                if portal_url:
                    view.add_item(discord.ui.Button(label="Trá»Ÿ vá» TÃ´ng MÃ´n", url=portal_url, emoji="â›©ï¸"))
                
                try:
                    await user.send(embed=embed, view=view)
                except: pass

    @daily_reminder_task.before_loop
    async def before_daily_reminder(self):
        await self.bot.wait_until_ready()

    async def cog_load(self):
        self.daily_reminder_task.start()
        self.spirit_stone_buff_task.start()

    async def cog_unload(self):
        self.daily_reminder_task.cancel()
        self.spirit_stone_buff_task.cancel()

    async def cog_check(self, ctx):
        """Prefix commands are disabled, but keeping for safety"""
        return False

    def interaction_check(self, interaction: discord.Interaction):
        """Kiá»ƒm tra kÃªnh vÃ  cháº·n DM cho Slash Commands"""
        if interaction.guild is None:
            return False

        # Náº¿u khÃ´ng giá»›i háº¡n kÃªnh thÃ¬ cho qua háº¿t
        if not self.bot.allowed_channel_ids:
            return True

        if interaction.channel_id not in self.bot.allowed_channel_ids:
            # Gá»­i tin nháº¯n áº©n (ephemeral) cho ngÆ°á»i gÃµ sai kÃªnh
            asyncio.create_task(interaction.response.send_message(
                "â›©ï¸ **Cáº¥m Cháº¿:** PhÃ¡p lá»‡nh nÃ y chá»‰ cÃ³ thá»ƒ thi triá»ƒn táº¡i cÃ¡c kÃªnh chuyÃªn biá»‡t cá»§a ThiÃªn Lam TÃ´ng!", 
                ephemeral=True
            ))
            return False
        return True

    @app_commands.command(name="start", description="Ghi danh vÃ o ThiÃªn Lam TÃ´ng")
    async def start(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "Äáº¡o há»¯u Ä‘Ã£ ghi danh nháº­p mÃ´n rá»“i! HÃ£y táº­p trung tu luyá»‡n, chá»› cÃ³ phÃ¢n tÃ¢m.", discord.Color.orange())
            return await interaction.followup.send(embed=embed, ephemeral=True)
        
        msg = await ask_ancestor(
            "ChÃ o Ä‘Ã³n Ä‘á»‡ tá»­ má»›i.", 
            f"Äá»‡ tá»­ {interaction.user.display_name} nháº­p mÃ´n. HÃ£y viáº¿t 2 cÃ¢u chÃ o Ä‘Ã³n trang trá»ng, thÃ¢m sÃ¢u."
        )
        
        await self.db.create_user(uid, interaction.user.display_name)
        await self.check_auto_role(interaction.user, 1) # Call new auto role check
        
        # QuÃ  nháº­p mÃ´n ngáº«u nhiÃªn
        item_ids = list(CultivationData.ITEMS.keys())
        gift_id = random.choice(item_ids)
        item_info = CultivationData.ITEMS[gift_id]
        
        now = time.time()
        expiry = now + item_info['duration']
        # Táº·ng vÃ o tÃºi Ä‘á»“
        inv = [{"id": gift_id, "count": 1, "expiry": expiry}]
        await self.db.update_user(uid, inventory=inv)
        
        rainbow_log(f"ğŸ [Nháº­p MÃ´n] ÄÃ£ táº·ng {item_info['name']} cho tÃ¢n Ä‘á»‡ tá»­ {interaction.user.display_name} ({uid}).")
        
        embed = txa_embed("â›©ï¸ ThiÃªn Lam TÃ´ng - Nháº­p MÃ´n Ghi Danh", f"**Tá»• SÆ° Tá»« DÆ°Æ¡ng phÃ¡n:**\n*\"{msg or 'ÄÆ°á»ng tu tiÃªn gian nan, Ä‘á»‡ tá»­ hÃ£y vá»¯ng tÃ¢m!'}\"*", Color.gold())
        embed.add_field(name="ğŸ QuÃ  TÃ¢n Thá»§", value=f"Nháº­n Ä‘Æ°á»£c `{item_info['emoji']} {item_info['name']}` (Háº¡n dÃ¹ng: {TXAFormat.duration_detail(item_info['duration'])})", inline=False)
        embed.add_field(name="ğŸ“œ PhÃ¡p Lá»‡nh Khai Má»Ÿ", value="`/nhiem_vu` â€¢ `/daily` â€¢ `/tu_luyen` â€¢ `/info`", inline=False)
        embed.set_footer(text="PhÃ¡p mÃ´n bÃ­ truyá»n - Kiá»ƒm tra /inventory Ä‘á»ƒ tháº¥y váº­t pháº©m.")
        await interaction.followup.send(embed=embed, ephemeral=True)

    @app_commands.command(name="admin_sync_roles", description="[Admin] Äá»“ng bá»™ Role & Nickname cho toÃ n bá»™ Ä‘á»‡ tá»­")
    async def admin_sync_roles(self, interaction: discord.Interaction):
        if interaction.user.id not in self.bot.admin_ids:
            return await interaction.response.send_message("ğŸš« NgÆ°Æ¡i khÃ´ng cÃ³ quyá»n nÄƒng nÃ y!", ephemeral=True)
        
        await interaction.response.defer(ephemeral=True)
        
        users = await self.db.get_all_users()
        count = 0
        failed = 0
        
        rainbow_log(f"ğŸ”„ Báº¯t Ä‘áº§u tiáº¿n trÃ¬nh Ä‘á»“ng bá»™ {len(users)} Ä‘á»‡ tá»­...")
        for u_data in users:
            uid = int(u_data['user_id'])
            layer = u_data['layer']
            u_name = u_data['name']
            
            try:
                member = interaction.guild.get_member(uid)
                if not member:
                    member = await interaction.guild.fetch_member(uid)
                
                if member:
                    rainbow_log(f"  [+] Äang quy cáº¥p cho: {member.display_name} ({u_name}) - Cáº¥p: {layer}")
                    await self.check_auto_role(member, layer)
                    count += 1
                    await asyncio.sleep(0.5) # TrÃ¡nh rate limit cá»§a Discord
                else:
                    rainbow_log(f"  [-] KhÃ´ng tÃ¬m tháº¥y member {uid} ({u_name}) trong server.")
                    failed += 1
            except Exception as e:
                rainbow_log(f"  [!] Lá»—i Ä‘á»“ng bá»™ cho {uid} ({u_name}): {e}")
                failed += 1
                
        embed = txa_embed(
            "ğŸ”„ Äá»“ng Bá»™ HoÃ n Táº¥t",
            f"ÄÃ£ cáº­p nháº­t Role & Nickname cho **{count}** Ä‘á»‡ tá»­.\nTháº¥t báº¡i/KhÃ´ng tÃ¬m tháº¥y: **{failed}**",
            discord.Color.green()
        )
        await interaction.followup.send(embed=embed)

    @app_commands.command(name="info", description="Xem thÃ´ng tin tu luyá»‡n (Real-time Update)")
    async def info(self, interaction: discord.Interaction, user: discord.Member = None):
        target_user = user or interaction.user
        uid = str(target_user.id)
        
        # Initial defer
        msg = await interaction.response.send_message("ğŸŒ€ Äang váº­n chuyá»ƒn linh lá»±c Ä‘á»ƒ soi xÃ©t cÄƒn cá»‘t...", ephemeral=True)
        
        start_time = time.time()
        # Loop for 3 minutes (180s)
        while time.time() - start_time < 180:
            user_data = await self.db.get_user(uid)
            if not user_data:
                if time.time() - start_time < 5: # First try
                     await interaction.edit_original_response(content="âš ï¸ NgÆ°Æ¡i chÆ°a bÆ°á»›c chÃ¢n vÃ o con Ä‘Æ°á»ng tu tiÃªn.")
                     return
                break # Stop if user deleted or something

            rank_name, rank_info = get_rank_info(user_data['layer'])
            progress = (user_data['exp'] / user_data['goal']) * 100
            
            # Mission Info
            # Check sect for daily limit
            daily_limit = 10 # Base limit
            sect_bonus_limit = 0
            if user_data.get('sect_id'):
                # Deterministic random based on date + uid
                today_str = datetime.now(VN_TZ).strftime("%Y%m%d")
                # Use a simple hash for reproducibility
                seed_str = f"{uid}{today_str}"
                seed = sum(ord(char) for char in seed_str) % (2**32 - 1) # Simple hash
                
                temp_random = random.Random(seed) # Use a temporary random instance
                sect_bonus_limit = temp_random.randint(3, 7)
                daily_limit += sect_bonus_limit
            
            missions_done = user_data['missions_completed']
            
            # Embed
            embed = txa_embed(
                f"ThÃ´ng Tin Tu Luyá»‡n: {target_user.name}",
                f"Äáº¡o hiá»‡u: **{user_data['name']}**",
                discord.Color.blue()
            )
            embed.set_thumbnail(url=target_user.avatar.url if target_user.avatar else None)
            
            embed.add_field(name="Cáº£nh Giá»›i", value=f"**{rank_name}** (Táº§ng {user_data['layer']})", inline=True)
            embed.add_field(name="Linh Lá»±c (EXP)", value=f"`{user_data['exp']:,} / {user_data['goal']:,}` ({progress:.1f}%)\n{TXAFormat.progress_bar(progress)}", inline=True)
            embed.add_field(name="ğŸ’ Linh Tháº¡ch", value=f"**{user_data['spirit_stones']:,} ğŸ’**", inline=True)
            
            sect_text = "TÃ¡n Tu"
            if user_data.get('sect_id'):
                 sect_text = f"Äá»‡ Tá»­ TÃ´ng MÃ´n (ID: {user_data['sect_id']})" # Simplified for now
                 embed.add_field(name="TÃ´ng MÃ´n", value=f"{sect_text}\n*(CÃ³ thÃªm **{random.randint(50, 100)} EXP** khi hoÃ n thÃ nh nhiá»‡m vá»¥)*", inline=True)
            else:
                 embed.add_field(name="TÃ´ng MÃ´n", value=sect_text, inline=True)
            
            # Mission Status
            mission_status = f"ÄÃ£ hoÃ n thÃ nh: **{missions_done}/{daily_limit}**"
            if sect_bonus_limit > 0:
                mission_status += f"\n*(ÄÃ£ cá»™ng thÃªm {sect_bonus_limit} nhiá»‡m vá»¥ tÃ´ng mÃ´n)*"

            current_mission = user_data.get('current_mission')
            if current_mission:
                try:
                    cm = current_mission # current_mission is already a dict
                    end_time = datetime.fromtimestamp(cm['end_time'], tz=VN_TZ)
                    now = datetime.now(VN_TZ)
                    remaining = end_time - now
                    
                    if remaining.total_seconds() > 0:
                        mission_title = next((m['title'] for m in user_data['missions'] if m['id'] == cm['id']), "Nhiá»‡m vá»¥ khÃ´ng rÃµ")
                        mission_status += f"\nâ³ Äang lÃ m: **{mission_title}**\nâ±ï¸ CÃ²n: `{TXAFormat.remaining_detail(int(remaining.total_seconds()))}`"
                    else:
                        mission_title = next((m['title'] for m in user_data['missions'] if m['id'] == cm['id']), "Nhiá»‡m vá»¥ khÃ´ng rÃµ")
                        mission_status += f"\nâœ… **{mission_title}** Ä‘Ã£ hoÃ n thÃ nh!\nKiá»ƒm tra `/nhiem_vu` Ä‘á»ƒ nháº­n thÆ°á»Ÿng."
                except Exception as e:
                    rainbow_log(f"Error parsing current_mission in info: {e}")
            
            embed.add_field(name="Nhiá»‡m Vá»¥ HÃ ng NgÃ y", value=mission_status, inline=False)
            embed.set_footer(text=f"Cáº­p nháº­t: {datetime.now(VN_TZ).strftime('%H:%M:%S')} | Tá»± há»§y sau 3 phÃºt")
            
            try:
                await interaction.edit_original_response(content=None, embed=embed)
            except:
                break # Error editing (deleted?)
            
            await asyncio.sleep(5) # Update every 5s
            
        # End loop - Delete
        try:
            await interaction.delete_original_response()
        except: pass

    @app_commands.command(name="daily", description="Nháº­n quÃ  hÃ ng ngÃ y")
    async def daily(self, interaction: discord.Interaction):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start` Ä‘á»ƒ nháº­p mÃ´n.", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
        
        now = datetime.now(VN_TZ)
        reset_hour = 7
        today_reset = now.replace(hour=reset_hour, minute=0, second=0, microsecond=0)
        if now < today_reset: today_reset -= timedelta(days=1)

        if user.get('last_daily_exp_reset', 0) < today_reset.timestamp():
            await self.db.update_user(uid, daily_exp=0, last_daily_exp_reset=now.timestamp())
            user['daily_exp'] = 0 
        
        if user['last_daily'] > today_reset.timestamp():
            await interaction.response.defer(ephemeral=True)
            next_reset = today_reset + timedelta(days=1)
            ts = int(next_reset.timestamp())
            loop_end = time.time() + 300 
            while time.time() < loop_end:
                now_loop = datetime.now(VN_TZ)
                diff = next_reset - now_loop
                total_seconds = int(diff.total_seconds())
                if total_seconds <= 0: break
                time_str = TXAFormat.duration_detail(total_seconds)
                embed = txa_embed(
                    "â³ Cáº¥m Cháº¿ Thá»• Náº¡p",
                    f"**Äáº¡o há»¯u hÃ£y tá»‹nh tÃ¢m!**\nLinh khÃ­ trá»i Ä‘áº¥t hiá»‡n táº¡i Ä‘ang khÃ´ kiá»‡t, cáº§n thá»i gian Ä‘á»ƒ tÃ¡i táº¡o hoÃ n nguyÃªn.\n\n"
                    f"ğŸŒ€ **Linh khÃ­ há»™i tá»¥ láº¡i sau:**\n`{time_str}`\n\n"
                    f"â° **ThiÃªn thá»i reset:** <t:{ts}:F> (**<t:{ts}:R>**)",
                    discord.Color.orange()
                )
                embed.set_thumbnail(url="https://hoathinh3d.moi/wp-content/uploads/2023/02/luyen-khi-10-van-nam-300x450.jpg")
                try: await interaction.edit_original_response(embed=embed)
                except: break 
                await asyncio.sleep(1)
            return
        
        await interaction.response.defer(ephemeral=True)
        logical_now = now - timedelta(hours=reset_hour)
        today_date = logical_now.strftime("%Y-%m-%d")
        yesterday_date = (logical_now - timedelta(days=1)).strftime("%Y-%m-%d")
        
        streak = user['daily_streak']
        if user['last_daily_date'] == yesterday_date:
             streak += 1
        elif user['last_daily_date'] != today_date:
             streak = 1
            
        reward = 1000 + (streak * 100)
        stones = 100 + (streak * 10)

        # Check for x3 buff
        buffs = user.get('buffs', {})
        is_x3 = buffs.get('stone_x3', 0) > time.time()
        if is_x3: stones *= 3

        can_add, limit = await self.check_daily_xp_limit(user, reward)
        if not can_add:
            return await interaction.followup.send(f"ğŸ›‘ NgÆ°Æ¡i Ä‘Ã£ Ä‘áº¡t giá»›i háº¡n tÃ­ch lÅ©y linh lá»±c trong ngÃ y (**{limit} EXP**). HÃ£y nghá»‰ ngÆ¡i!", ephemeral=True)
        
        exp = user['exp'] + reward
        layer = user['layer']
        goal = user['goal']
        daily_exp = user.get('daily_exp', 0) + reward
        leveled_up = False
        while exp >= goal:
            exp -= goal
            layer += 1
            goal = layer * 1000
            leveled_up = True
            
        await self.db.update_user(uid, exp=exp, layer=layer, goal=goal, last_daily=now.timestamp(), last_daily_date=today_date, daily_streak=streak, daily_exp=daily_exp, spirit_stones=user['spirit_stones'] + stones)
        if leveled_up: await self.check_auto_role(interaction.user, layer) 
        
        msg = await ask_ancestor("Ban thÆ°á»Ÿng Ä‘iá»ƒm danh.", f"Äá»‡ tá»­ nháº­n {reward} EXP ngÃ y {streak}. Viáº¿t 1 cÃ¢u thÃ¢m sÃ¢u.")
        
        embed = txa_embed("ğŸ ThiÃªn Äáº¡o Ban PhÆ°á»›c", f"**Tá»• SÆ° Tá»« DÆ°Æ¡ng phÃ¡n:**\n*\"{msg or 'Linh khÃ­ quÃ¡n Ä‘á»‰nh, cÄƒn cá»‘t tinh anh!'}\"*", Color.blue())
        embed.add_field(name="ğŸ“ˆ Linh Lá»±c", value=f"**+{reward} EXP**", inline=True)
        embed.add_field(name="ğŸ’° Linh Tháº¡ch", value=f"**+{stones} ğŸ’**{' (ğŸ° x3)' if is_x3 else ''}", inline=True)
        embed.add_field(name="ğŸ”¥ Äáº¡o TÃ¢m Chuá»—i", value=f"**{streak} ngÃ y**", inline=True)
        if leveled_up: embed.add_field(name="ğŸ”¥ Äá»˜T PHÃ Cáº¢NH GIá»šI", value=f"Äá»‡ tá»­ Ä‘Ã£ Ä‘áº¡t tá»›i **Táº§ng {layer}**!", inline=False)
        await interaction.followup.send(embed=embed, ephemeral=True)

    @app_commands.command(name="tu_luyen", description="Tá»a thiá»n luyá»‡n khÃ­")
    async def tu_luyen(self, interaction: discord.Interaction):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start` Ä‘á»ƒ nháº­p mÃ´n.", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
        
        await interaction.response.defer(ephemeral=True)
        
        duration = random.randint(15, 30)
        start_time = time.time()
        end_time = int(start_time + duration)
        
        embed = txa_embed("ğŸ§˜ Äang Nháº­p Äá»‹nh Tu Luyá»‡n", f"Thanh táº©y thÃ¢n thá»ƒ, há»™i tá»¥ linh khÃ­ trá»i Ä‘áº¥t mÆ°á»i váº¡n nÄƒm...\nâ³ Æ¯á»›c tÃ­nh hoÃ n táº¥t: <t:{end_time}:t> (<t:{end_time}:R>)", Color.blue())
        bar = TXAFormat.progress_bar(0, 15)
        rem_str = TXAFormat.remaining_detail(duration)
        embed.add_field(name="âœ¨ Tiáº¿n Äá»™", value=f"`{bar}` ({TXAFormat.pad2(0)}%) - {rem_str}")
        msg = await interaction.followup.send(embed=embed, ephemeral=True)
        
        # Cáº­p nháº­t thanh tiáº¿n trÃ¬nh má»—i 1 giÃ¢y (real-time)
        while True:
            now_t = time.time()
            elapsed = now_t - start_time
            remaining = max(0, int(end_time - now_t))
            percent = min(100, int((elapsed / duration) * 100))
            
            if percent >= 100: break
            
            # Chá»n narrative text theo %
            stage_msg = self.NARRATIVE_STAGES[0][1]
            for threshold, text in self.NARRATIVE_STAGES:
                if percent >= threshold:
                    stage_msg = text
            
            # Cáº­p nháº­t má»—i 1 giÃ¢y
            bar = TXAFormat.progress_bar(percent, 15)
            rem_str = TXAFormat.remaining_detail(remaining)
            
            embed.description = f"{stage_msg}\nâ³ Æ¯á»›c tÃ­nh hoÃ n táº¥t: <t:{end_time}:t> (<t:{end_time}:R>)"
            embed.set_field_at(0, name="âœ¨ Tiáº¿n Äá»™", value=f"`{bar}` ({TXAFormat.pad2(percent)}%) - {rem_str}")
            
            try: await msg.edit(embed=embed)
            except: pass
            
            if percent >= 100: break
            await asyncio.sleep(1)
        
        # Re-fetch user to get latest state
        user = await self.db.get_user(uid)
        gain = random.randint(50, 150) + (user['layer'] * 5)

        can_add, limit = await self.check_daily_xp_limit(user, gain)
        if not can_add:
            res_embed = txa_embed("ğŸ›‘ Kiá»‡t Sá»©c", f"NgÆ°Æ¡i Ä‘Ã£ Ä‘áº¡t giá»›i háº¡n tÃ­ch lÅ©y linh lá»±c trong ngÃ y (**{limit} EXP**). HÃ£y nghá»‰ ngÆ¡i, tham gia hoáº¡t Ä‘á»™ng giáº£i trÃ­ (nhÆ° nghe nháº¡c) Ä‘á»ƒ thÆ° giÃ£n!", Color.orange())
            res_embed.set_footer(text="CÃ´ng khÃ³a hoÃ n táº¥t. (Nháº¥n Ä‘á»ƒ Ä‘Ã³ng)")
            try: await msg.edit(embed=res_embed)
            except: pass
            return
        
        # Bonus Streak (>= 3 ngÃ y)
        bonus_msg = ""
        if user['daily_streak'] >= 3:
            bonus_pct = min(0.5, (user['daily_streak'] // 3) * 0.05)
            bonus_xp = int(gain * bonus_pct)
            gain += bonus_xp
            bonus_msg = f"\nğŸ”¥ **Ká»³ DuyÃªn Phá»¥ Trá»£:** +{bonus_xp} EXP (Streak x{user['daily_streak']})"

        exp = user['exp'] + gain
        layer = user['layer']
        goal = user['goal']
        daily_exp = user.get('daily_exp', 0) + gain
        
        leveled_up = False
        while exp >= goal:
            exp -= goal
            layer += 1
            goal = layer * 1000
            leveled_up = True
            
        # Linh tháº¡ch ngáº«u nhiÃªn khi tu luyá»‡n
        stones = random.randint(5, 15)
        # Check for x3 buff
        is_x3 = user.get('buffs', {}).get('stone_x3', 0) > time.time()
        if is_x3: stones *= 3
        
        await self.db.update_user(uid, exp=exp, layer=layer, goal=goal, daily_exp=daily_exp, spirit_stones=user['spirit_stones'] + stones)
        if leveled_up: await self.check_auto_role(interaction.user, layer) # Call new auto role check
        
        res_text = f"Chu thiÃªn tuáº§n hoÃ n káº¿t thÃºc, linh khÃ­ Ä‘Ã£ Ä‘Æ°á»£c luyá»‡n hÃ³a.\nğŸ“ˆ Nháº­n Ä‘Æ°á»£c: **{gain} EXP** linh lá»±c.\nğŸ’° Nháº­n Ä‘Æ°á»£c: **{stones} Linh Tháº¡ch**{ ' (ğŸ° x3)' if is_x3 else ''}.{bonus_msg}"
        res_embed = txa_embed("ğŸ§˜ Tu Luyá»‡n HoÃ n Táº¥t", res_text, Color.green())
        if leveled_up: res_embed.add_field(name="ğŸ”¥ Äá»˜T PHÃ Cáº¢NH GIá»šI", value=f"ChÃºc má»«ng Ä‘á»‡ tá»­ Ä‘á»™t phÃ¡ lÃªn **Táº§ng {layer}**!")
        
        res_embed.set_footer(text="CÃ´ng khÃ³a hoÃ n táº¥t. (Nháº¥n Ä‘á»ƒ Ä‘Ã³ng)")
        try:
            await msg.edit(embed=res_embed)
        except: pass

    async def generate_missions(self, user):
        """Táº¡o danh sÃ¡ch nhiá»‡m vá»¥ má»›i via AI hoáº·c Fallback"""
        uid = str(user['user_id'])
        is_sect = user.get('sect_id') is not None
        num_missions = 10 if is_sect else 5
        prompt = (
            f"Táº¡o {num_missions} nhiá»‡m vá»¥ tu tiÃªn ngáº¯n gá»n, thÃ¢m sÃ¢u. "
            "PhÃ¢n cáº¥p Ä‘á»™ khÃ³ tá»« 1 (Dá»…) Ä‘áº¿n 10 (Cá»±c khÃ³). "
            "Pháº§n thÆ°á»Ÿng (reward) tá»« 500 Ä‘áº¿n 10000 tÃ¹y Ä‘á»™ khÃ³. "
            "Thá»i gian thá»±c hiá»‡n (time) tá»« 30 Ä‘áº¿n 300 giÃ¢y. "
            "Format JSON: [{'id': 1, 'title': '...', 'desc': '...', 'diff': 1-10, 'reward': int, 'time': int}]"
        )
        
        rainbow_log(f"ğŸ”® Äang thá»‰nh thá»‹ Tá»• SÆ° Tá»« DÆ°Æ¡ng táº¡o cÃ´ng khÃ³a cho {user['name']}...")
        ai_res = await ask_ancestor("NgÆ°á»i táº¡o nhiá»‡m vá»¥ tu tiÃªn.", prompt, json_mode=True)
        
        missions = []
        try:
            raw_missions = json.loads(ai_res)
            if isinstance(raw_missions, dict): 
                raw_missions = raw_missions.get('missions', [])
                
            for i, m in enumerate(raw_missions):
                diff = m.get('diff', random.randint(1, 10))
                missions.append({
                    "id": i + 1,
                    "title": m.get('title', "Nhiá»‡m vá»¥ vÃ´ danh"),
                    "desc": m.get('desc', "Äi tÃ¬m cÆ¡ duyÃªn..."),
                    "difficulty": diff,
                    "time": m.get('time', diff * 30),
                    "reward": m.get('reward', diff * 500 + random.randint(100, 300)),
                    "stones": random.randint(5, 15) + (diff * 2), # Base stones
                    "success_rate": max(10, 100 - (diff * 8)),
                    "done": False
                })
            rainbow_log(f"âœ… AI Ä‘Ã£ ban xuá»‘ng {len(missions)} cÃ´ng khÃ³a má»›i cho {user['name']}.")
        except Exception as e:
            rainbow_log(f"âš ï¸ Thá»‰nh thá»‹ AI tháº¥t báº¡i: {e}. Sá»­ dá»¥ng bÃ­ tá»‹ch Fallback.")
            # Fallback using CultivationData
            num_fallback = 10 if is_sect else 5
            for i in range(num_fallback):
                diff = (i % 5) + 1
                mission_title = CultivationData.get_random_mission()
                missions.append({
                    "id": i + 1,
                    "title": mission_title,
                    "desc": f"Thá»±c hiá»‡n {mission_title} Ä‘á»ƒ tÃ­ch lÅ©y kinh nghiá»‡m.",
                    "difficulty": diff,
                    "time": diff * 40,
                    "reward": diff * 350 + random.randint(10, 50), # Random XP base
                    "stones": random.randint(5, 10) + diff, # Fallback stones
                    "success_rate": 100 - (diff * 12),
                    "done": False
                })
        
        return missions

    async def finalize_mission(self, interaction: discord.Interaction, uid: str, user: dict, mission_id: int, silent: bool = False):
        if not silent: await interaction.response.defer(ephemeral=True)
        mission = next((m for m in user['missions'] if m['id'] == mission_id), None)
        if not mission:
            await self.db.update_user(uid, current_mission=None)
            return
        user = await self.db.get_user(uid)
        if not user or not user.get('current_mission'): return
        
        success_rate = mission['success_rate']
        # Pet "Tiá»ƒu Háº¯c" buff (kiá»ƒm tra háº¡n dÃ¹ng)
        now = time.time()
        if any(i['id'] == 'tu_tieu_hac' and i.get('expiry', 0) > now for i in user['inventory']):
            success_rate += 20
        success = random.randint(1, 100) <= success_rate
        
        await self.db.update_user(uid, current_mission=None)
        if success:
            new_missions = user['missions']
            for m in new_missions:
                if m['id'] == mission['id']: m['done'] = True
            
            reward = mission['reward']
            
            # Stones logic update
            base_stones = mission.get('stones', random.randint(20, 50))
            buffs = user.get('buffs', {})
            is_x3 = buffs.get('stone_x3', 0) > time.time()
            stones = base_stones * 3 if is_x3 else base_stones

            can_add, limit = await self.check_daily_xp_limit(user, reward)
            if not can_add:
                if not silent: return await interaction.followup.send(f"ğŸ›‘ Äáº¡t giá»›i háº¡n EXP (**{limit}**).", ephemeral=True)
                return 

            if user.get('sect_id'): reward += random.randint(50, 100)
            bonus_msg = ""
            if user['daily_streak'] >= 3:
                bonus_xp = int(reward * min(0.5, (user['daily_streak'] // 3) * 0.05))
                reward += bonus_xp
                bonus_msg = f"\nğŸ”¥ **Streak Bonus:** +{bonus_xp} EXP"

            exp = user['exp'] + reward
            layer = user['layer']
            goal = user['goal']
            daily_exp = user.get('daily_exp', 0) + reward
            leveled_up = False
            while exp >= goal:
                exp -= goal
                layer += 1
                goal = max(layer * 1000, 200)
                leveled_up = True
            
            await self.db.update_user(uid, missions=new_missions, missions_completed=user['missions_completed'] + 1, exp=exp, layer=layer, goal=goal, daily_exp=daily_exp, spirit_stones=user['spirit_stones'] + stones)
            if leveled_up: await self.check_auto_role(interaction.user, layer) 
            
            if not silent:
                res_embed = txa_embed("âœ… HoÃ n ThÃ nh", f"**{mission['title']}** xong!\nğŸ“ˆ: **{reward} EXP**{bonus_msg}\nğŸ’°: **{stones} Linh Tháº¡ch**{ ' (ğŸ° x3)' if is_x3 else ''}", Color.green())
                if leveled_up: res_embed.add_field(name="ğŸ”¥ Äá»˜T PHÃ", value=f"Táº§ng {layer}!")
                await interaction.followup.send(embed=res_embed, ephemeral=True)
        else:
            new_missions = user['missions']
            for m in new_missions:
                if m['id'] == mission['id']: m['retry_time'] = int(time.time() + 180)
            await self.db.update_user(uid, missions=new_missions)
            if not silent:
                await interaction.followup.send(embed=txa_embed("âŒ Tháº¥t Báº¡i", f"**{mission['title']}** tháº¥t báº¡i. Chá» 3 phÃºt.", Color.red()), ephemeral=True)

    def get_diff_name(self, diff: int):
        """Chuyá»ƒn Ä‘á»™ khÃ³ thÃ nh danh xÆ°ng tu tiÃªn"""
        data = {
            1: "ğŸŸ¢ Thuáº­n Buá»“m XuÃ´i GiÃ³",
            2: "ğŸŸ¡ SÃ³ng YÃªn Biá»ƒn Láº·ng",
            3: "ğŸŸ  Phong Ba BÃ£o TÃ¡p",
            4: "ğŸ”´ Káº» Sá»‘ng NgÆ°á»i Cháº¿t",
            5: "ğŸ’€ Cá»­u Tá»­ Nháº¥t Sinh"
        }
        return data.get(diff, "â“ VÃ´ Äá»‹nh")

    @app_commands.command(name="nhiem_vu", description="Xem danh sÃ¡ch nhiá»‡m vá»¥ hÃ´m nay")
    async def nhiem_vu(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user: return await interaction.followup.send("â›©ï¸ NgÆ°Æ¡i chÆ°a ghi danh!", ephemeral=True)
        
        now = datetime.now(VN_TZ)
        # Reset lÃºc 7h sÃ¡ng
        reset_hour = 7
        today_reset = now.replace(hour=reset_hour, minute=0, second=0, microsecond=0)
        if now < today_reset: today_reset -= timedelta(days=1)
        
        # Reset daily exp if needed
        if user.get('last_daily_exp_reset', 0) < today_reset.timestamp():
            await self.db.update_user(uid, daily_exp=0, last_daily_exp_reset=now.timestamp())
            user['daily_exp'] = 0 # Update local user object for current operation
        
        # Calculate dynamic daily limit
        daily_limit = 10 # Base limit
        sect_bonus_limit = 0
        if user.get('sect_id'):
            today_str = datetime.now(VN_TZ).strftime("%Y%m%d")
            seed_str = f"{uid}{today_str}"
            seed = sum(ord(char) for char in seed_str) % (2**32 - 1)
            temp_random = random.Random(seed)
            sect_bonus_limit = temp_random.randint(3, 7)
            daily_limit += sect_bonus_limit
        
        # Kiá»ƒm tra reset nhiá»‡m vá»¥
        should_refresh = False
        if user['last_mission_reset'] < today_reset.timestamp():
            should_refresh = True
        elif user['missions_completed'] >= daily_limit: # Check against dynamic limit
            # If all missions are done and limit reached, no refresh
            pass
        elif all(m['done'] for m in user['missions']):
            # If all current missions are done but limit not reached, refresh
            should_refresh = True
            rainbow_log(f"ğŸ”„ {user['name']} Ä‘Ã£ hoÃ n táº¥t Ä‘á»£t cÃ´ng khÃ³a, Ä‘ang lÃ m má»›i...")

        if should_refresh:
            missions = await self.generate_missions(user)
            await self.db.update_user(uid, missions=missions, last_mission_reset=now.timestamp(), missions_completed=0) # Reset missions_completed on new day
            user['missions'] = missions
            user['missions_completed'] = 0 # Update local user object

        # Kiá»ƒm tra nhiá»‡m vá»¥ Ä‘ang lÃ m (Äá»“ng bá»™ ID)
        current_mission_id = None
        if user.get('current_mission'):
            curr = user['current_mission']
            remaining = int(curr['end_time'] - time.time())
            if remaining > 0:
                current_mission_id = int(curr['id'])
            else:
                # Tá»± Ä‘á»™ng finalize náº¿u Ä‘Ã£ xong
                asyncio.create_task(self.finalize_mission(interaction, uid, user, int(curr['id']), silent=True))

        async def build_desc(curr_rem=0):
            d = f"ğŸ“Š **Tiáº¿n Ä‘á»™ hÃ´m nay:** `{user['missions_completed']}/{daily_limit}` cÃ´ng khÃ³a\n"
            if sect_bonus_limit > 0:
                d += f"*(ÄÃ£ cá»™ng thÃªm {sect_bonus_limit} nhiá»‡m vá»¥ tÃ´ng mÃ´n)*\n"
            d += "\n"

            has_tieu_hac = any(i['id'] == 'tu_tieu_hac' and i.get('expiry', 0) > time.time() for i in user.get('inventory', []))
            
            for m in user['missions']:
                m_id = m['id']
                if m_id == current_mission_id and curr_rem > 0:
                    status = "âš”ï¸"
                    time_info = f" â€¢ **CÃ²n {TXAFormat.remaining_detail(curr_rem)}**"
                elif m['done']:
                    status = "âœ…"
                    time_info = ""
                elif m.get('retry_time') and time.time() < m['retry_time']:
                    status = "âŒ"
                    rem = int(m['retry_time'] - time.time())
                    time_info = f" â€¢ **Thá»­ láº¡i sau {rem}s**"
                else:
                    status = "â³"
                    time_info = ""
                
                diff_text = self.get_diff_name(m['difficulty'])
                rate = m['success_rate']
                bonus_rate_text = f" (+20%)" if has_tieu_hac else ""
                
                d += f"{status} **[{m['id']}] {m['title']}**{time_info}\n"
                d += f"â”” *Äá»™ khÃ³: {diff_text}*\n"
                
                stones_show = m.get('stones', 10)
                is_x3 = user.get('buffs', {}).get('stone_x3', 0) > time.time()
                stone_txt = f"{stones_show*3 if is_x3 else stones_show} ğŸ’{' (ğŸ°x3)' if is_x3 else ''}"
                
                d += f"â”” *ThÆ°á»Ÿng: {TXAFormat.number(m['reward'])} EXP â€¢ {stone_txt} â€¢ TG: {TXAFormat.remaining_detail(m['time'])} â€¢ ThÃ nh cÃ´ng: {rate}%{bonus_rate_text}*\n\n"
            return d

        curr_rem = 0
        if current_mission_id:
            curr_rem = int(user['current_mission']['end_time'] - time.time())

        desc = await build_desc(curr_rem)
        embed = txa_embed("ğŸ“œ ThiÃªn Lam Linh Báº£ng - Nhiá»‡m Vá»¥", desc, Color.blue())
        embed.set_footer(text="Sá»­ dá»¥ng /lam_nhiem_vu [id] Ä‘á»ƒ tiáº¿p nháº­n cÆ¡ duyÃªn.")
        msg = await interaction.followup.send(embed=embed, ephemeral=True)

        if current_mission_id and curr_rem > 0:
            loop_end = time.time() + 300
            while time.time() < loop_end:
                now_t = time.time()
                curr_rem = int(user['current_mission']['end_time'] - now_t)
                
                if curr_rem <= 0:
                    # Cáº­p nháº­t láº§n cuá»‘i khi xong
                    embed.description = await build_desc(0)
                    try: await msg.edit(embed=embed)
                    except: pass
                    break
                
                embed.description = await build_desc(curr_rem)
                try: await msg.edit(embed=embed)
                except: break
                await asyncio.sleep(1)

    @app_commands.command(name="lam_nhiem_vu", description="Báº¯t Ä‘áº§u thá»±c hiá»‡n nhiá»‡m vá»¥")
    @app_commands.describe(mission_id="ID cá»§a nhiá»‡m vá»¥ trong danh sÃ¡ch cá»§a ngÆ°Æ¡i")
    async def lam_nhiem_vu(self, interaction: discord.Interaction, mission_id: int):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start`.", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
        
        # Calculate dynamic daily limit
        daily_limit = 10 # Base limit
        if user.get('sect_id'):
            today_str = datetime.now(VN_TZ).strftime("%Y%m%d")
            seed_str = f"{uid}{today_str}"
            seed = sum(ord(char) for char in seed_str) % (2**32 - 1)
            temp_random = random.Random(seed)
            daily_limit += temp_random.randint(3, 7)

        if user['missions_completed'] >= daily_limit:
            embed = txa_embed("âš ï¸ Kiá»‡t Sá»©c", "NgÆ°Æ¡i Ä‘Ã£ kiá»‡t sá»©c! HÃ´m nay lÃ m Ä‘á»§ nhiá»‡m vá»¥ rá»“i, hÃ£y nghá»‰ ngÆ¡i hoáº·c báº¿ quan dÆ°á»¡ng tháº§n.", discord.Color.orange())
            return await interaction.response.send_message(embed=embed, ephemeral=True)

        if mission_id == -1:
            embed = txa_embed("â›©ï¸ Tá»• SÆ° Nháº¯c Nhá»Ÿ", "HÃ£y kiá»ƒm tra láº¡i danh sÃ¡ch nhiá»‡m vá»¥ cá»§a ngÆ°Æ¡i!", discord.Color.orange())
            return await interaction.response.send_message(embed=embed, ephemeral=True)

        mission = next((m for m in user['missions'] if m['id'] == mission_id), None)
        if not mission:
            embed = txa_embed("âŒ Lá»—i Tháº§n Thá»©c", "KhÃ´ng tÃ¬m tháº¥y cÃ´ng khÃ³a nÃ y trong tÃ ng thÆ°!", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
        if mission['done']:
            embed = txa_embed("âœ… CÃ´ng KhÃ³a HoÃ n Táº¥t", "CÃ´ng khÃ³a nÃ y ngÆ°Æ¡i Ä‘Ã£ hoÃ n táº¥t viÃªn mÃ£n!", discord.Color.green())
            return await interaction.response.send_message(embed=embed, ephemeral=True)

        # Kiá»ƒm tra cooldown tháº¥t báº¡i
        if mission.get('retry_time') and time.time() < mission['retry_time']:
            remaining = int(mission['retry_time'] - time.time())
            embed = txa_embed(
                "â³ TÃ¢m Linh Äang Phá»¥c Há»“i",
                f"NgÆ°Æ¡i Ä‘Ã£ tháº¥t báº¡i nhiá»‡m vá»¥ **{mission['title']}**.\n"
                f"â±ï¸ Cáº§n nghá»‰ ngÆ¡i thÃªm: **{remaining} giÃ¢y**.",
                discord.Color.red()
            )
            return await interaction.response.send_message(embed=embed, ephemeral=True)

        if user['current_mission']:
            # Kiá»ƒm tra náº¿u Ä‘ang trong tiáº¿n trÃ¬nh
            curr = user['current_mission']
            remaining = int(curr['end_time'] - time.time())
            if remaining > 0:
                # Láº¥y tÃªn nhiá»‡m vá»¥ Ä‘ang lÃ m
                curr_mission = next((m for m in user['missions'] if m['id'] == curr['id']), None)
                curr_name = curr_mission['title'] if curr_mission else "KhÃ´ng rÃµ"
                
                embed = txa_embed(
                    "â³ CÃ´ng KhÃ³a Äang Tiáº¿n HÃ nh",
                    f"NgÆ°Æ¡i Ä‘ang dá»‘c sá»©c thá»±c hiá»‡n: **{curr_name}**\n\n"
                    f"â±ï¸ HoÃ n thÃ nh sau: <t:{int(curr['end_time'])}:R>\n"
                    f"ğŸ“Š Thá»i gian cÃ²n láº¡i: **{TXAFormat.remaining_detail(remaining)}**",
                    discord.Color.orange()
                )
                embed.set_footer(text="HÃ£y kiÃªn nháº«n, Ä‘áº¡o tÃ¢m sáº½ dáº«n Ä‘áº¡o.")
                return await interaction.response.send_message(embed=embed, ephemeral=True)
            else:
                # Nhiá»‡m vá»¥ Ä‘Ã£ xong nhÆ°ng chÆ°a Ä‘Æ°á»£c xá»­ lÃ½ (bot restart giá»¯a chá»«ng)
                # Xá»­ lÃ½ káº¿t quáº£ ngay
                await self.finalize_mission(interaction, uid, user, curr['id'])
                return

        await interaction.response.defer(ephemeral=True)
        
        # Báº¯t Ä‘áº§u lÃ m
        start_t = time.time()
        end_time = int(start_t + mission['time'])
        await self.db.update_user(uid, current_mission={"id": mission['id'], "end_time": end_time})
        
        # Äá»ƒ trÃ¡nh viá»‡c hiá»‡n "2 phÃºt trÆ°á»›c" khi mÃ¡y chá»§ lá»‡ch giá», ta dÃ¹ng text thá»§ cÃ´ng bÃªn dÆ°á»›i káº¿t há»£p timestamp
        embed = txa_embed(f"âš”ï¸ Tiáº¿p Nháº­n: {mission['title']}", f"{self.NARRATIVE_STAGES[0][1]}\nâ³ Æ¯á»›c tÃ­nh hoÃ n táº¥t: <t:{end_time}:t> (<t:{end_time}:R>)", Color.purple())
        bar = TXAFormat.progress_bar(0, 15)
        rem_str = TXAFormat.remaining_detail(mission['time'])
        embed.add_field(name="âœ¨ Tiáº¿n Äá»™", value=f"`{bar}` ({TXAFormat.pad2(0)}%) - {rem_str}")
        msg = await interaction.followup.send(embed=embed, ephemeral=True)
        
        # Cáº­p nháº­t progress má»—i 1 giÃ¢y (real-time)
        last_stage_msg = self.NARRATIVE_STAGES[0][1]
        while True:
            now_t = time.time()
            elapsed = now_t - start_t
            remaining = max(0, int(end_time - now_t))
            percent = min(100, int((elapsed / mission['time']) * 100))
            
            if percent >= 100: break
            
            # Chá»n narrative text theo %
            stage_msg = self.NARRATIVE_STAGES[0][1]
            for threshold, text in self.NARRATIVE_STAGES:
                if percent >= threshold:
                    stage_msg = text
            
            bar = TXAFormat.progress_bar(percent, 15)
            rem_str = TXAFormat.remaining_detail(remaining)
            
            # Chá»‰ cáº­p nháº­t náº¿u cÃ³ sá»± thay Ä‘á»•i Ä‘Ã¡ng ká»ƒ hoáº·c tin nháº¯n má»›i
            embed.description = f"{stage_msg}\nâ³ Æ¯á»›c tÃ­nh hoÃ n táº¥t: <t:{end_time}:t> (<t:{end_time}:R>)"
            embed.set_field_at(0, name="âœ¨ Tiáº¿n Äá»™", value=f"`{bar}` ({TXAFormat.pad2(percent)}%) - {rem_str}")
            
            try: await msg.edit(embed=embed)
            except: pass
            
            if percent >= 100: break
            await asyncio.sleep(1)

        # Xá»­ lÃ½ káº¿t quáº£
        user = await self.db.get_user(uid) # Re-fetch
        success = random.randint(1, 100) <= mission['success_rate']
        
        # XÃ³a current_mission
        await self.db.update_user(uid, current_mission=None)
        
        if success:
            # ... (giá»¯ nguyÃªn logic thÃ nh cÃ´ng) ...
            # Mark done in list
            new_missions = user['missions']
            for m in new_missions:
                if m['id'] == mission['id']: m['done'] = True
            
            reward = mission['reward']

            can_add, limit = await self.check_daily_xp_limit(user, reward)
            if not can_add:
                 return await interaction.followup.send(f"ğŸ›‘ NgÆ°Æ¡i Ä‘Ã£ Ä‘áº¡t giá»›i háº¡n tÃ­ch lÅ©y linh lá»±c trong ngÃ y (**{limit} EXP**). HÃ£y nghá»‰ ngÆ¡i, tham gia hoáº¡t Ä‘á»™ng giáº£i trÃ­ (nhÆ° nghe nháº¡c) Ä‘á»ƒ thÆ° giÃ£n!", ephemeral=True)
            
            # Sect Bonus XP
            if user.get('sect_id'):
                sect_bonus_xp = random.randint(50, 100)
                reward += sect_bonus_xp
            
            # Bonus streak
            bonus_msg = ""
            if user['daily_streak'] >= 3:
                bonus_pct = min(0.5, (user['daily_streak'] // 3) * 0.05)
                bonus_xp = int(reward * bonus_pct)
                reward += bonus_xp
                bonus_msg = f"\nğŸ”¥ **HÃ o Quang Streak:** +{bonus_xp} EXP"

            exp = user['exp'] + reward
            layer = user['layer']
            goal = user['goal']
            leveled_up = False
            while exp >= goal:
                exp -= goal
                layer += 1
                goal = max(layer * 1000, 200)
                leveled_up = True
            
            await self.db.update_user(uid, missions=new_missions, missions_completed=user['missions_completed'] + 1, exp=exp, layer=layer, goal=goal)
            if leveled_up: await self.check_auto_role(interaction.user, layer) # Call new auto role check
            
            res_embed = txa_embed("âœ… CÆ¡ DuyÃªn ViÃªn MÃ£n", f"ChÃºc má»«ng! NgÆ°Æ¡i Ä‘Ã£ hoÃ n thÃ nh **{mission['title']}**.\nğŸ“ˆ Nháº­n Ä‘Æ°á»£c: **{reward} EXP** linh lá»±c.{bonus_msg}", Color.green())
            if leveled_up: res_embed.add_field(name="ğŸ”¥ Äá»˜T PHÃ Cáº¢NH GIá»šI", value=f"NgÆ°Æ¡i Ä‘Ã£ Ä‘áº¡t tá»›i **Táº§ng {layer}**!")
        else:
            # Ghi láº¡i thá»i gian tháº¥t báº¡i (3 phÃºt)
            new_missions = user['missions']
            for m in new_missions:
                if m['id'] == mission['id']:
                    m['retry_time'] = int(time.time() + 180)
            await self.db.update_user(uid, missions=new_missions)
            
            res_embed = txa_embed("âŒ TÃ¢m Ma XÃ¢m Nháº­p", f"ÄÃ¡ng tiáº¿c! NgÆ°Æ¡i Ä‘Ã£ tháº¥t báº¡i trong nhiá»‡m vá»¥ **{mission['title']}**.\nâ±ï¸ Cáº§n tá»‹nh tÃ¢m trong **3 phÃºt** Ä‘á»ƒ cÃ³ thá»ƒ thá»­ láº¡i.", Color.red())

        await msg.edit(embed=res_embed)

    @lam_nhiem_vu.autocomplete("mission_id")
    async def _mission_autocomplete(self, interaction: discord.Interaction, current: str):
        user = await self.db.get_user(str(interaction.user.id))
        if not user or not user.get('missions'): return []
        
        # Calculate dynamic daily limit
        daily_limit = 10 # Base limit
        if user.get('sect_id'):
            today_str = datetime.now(VN_TZ).strftime("%Y%m%d")
            seed_str = f"{str(interaction.user.id)}{today_str}"
            seed = sum(ord(char) for char in seed_str) % (2**32 - 1)
            temp_random = random.Random(seed)
            daily_limit += temp_random.randint(3, 7)

        choices = []
        pending = [m for m in user['missions'] if not m['done']]
        
        if user['missions_completed'] >= daily_limit:
            return [app_commands.Choice(name="ğŸ’¤ NgÆ°Æ¡i Ä‘Ã£ kiá»‡t sá»©c! HÃ£y nghá»‰ ngÆ¡i Ä‘áº¿n ngÃ y mai.", value=-1)]
            
        if not pending:
            return [app_commands.Choice(name="âœ¨ ÄÃ£ xong Ä‘á»£t nÃ y! DÃ¹ng /nhiem_vu Ä‘á»ƒ nháº­n Ä‘á»£t tiáº¿p theo.", value=-1)]

        for m in pending:
            title = f"{m['id']}. {m['title']} ({self.get_diff_name(m['difficulty'])})"
            if current.lower() in title.lower():
                choices.append(app_commands.Choice(name=title, value=m['id']))
        return choices[:25]

    @app_commands.command(name="bxh", description="Báº£ng xáº¿p háº¡ng ThiÃªn Lam TÃ´ng")
    async def bxh(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start` Ä‘á»ƒ nháº­p mÃ´n.", discord.Color.red())
            return await interaction.followup.send(embed=embed, ephemeral=True)
            
        top = await self.db.get_top_users(10)
        
        desc = "```ansi\n"
        desc += "\u001b[1;33mâ”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”“\u001b[0m\n"
        desc += "\u001b[1;33mâ”ƒ Háº NG â”ƒ      Äáº O Há»®U      â”ƒ Cáº¢NH GIá»šI â”ƒ   TU VI   â”ƒ\u001b[0m\n"
        desc += "\u001b[1;33mâ”£â”â”â”â”â•‹â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‹â”â”â”â”â”â”â”â”â”â”â”â•‹â”â”â”â”â”â”â”â”â”â”â”â”«\u001b[0m\n"
        
        for i, u in enumerate(top, 1):
            rank_name, info = get_rank_info(u['layer'])
            # Cáº¯t ngáº¯n tÃªn náº¿u quÃ¡ dÃ i
            name = (u['name'][:15] + '..') if len(u['name']) > 17 else u['name']
            
            # Emojis vÃ  mÃ u sáº¯c cho Top 3
            if i == 1: medal, color = "ğŸ¥‡", "\u001b[1;33m" # Gold
            elif i == 2: medal, color = "ğŸ¥ˆ", "\u001b[1;37m" # Silver
            elif i == 3: medal, color = "ğŸ¥‰", "\u001b[1;31m" # Bronze
            else: medal, color = f"{i:2}", "\u001b[0;37m"
            
            exp_str = f"{u['exp']:,}"
            desc += f"â”ƒ {medal} â”ƒ {color}{name:<19}\u001b[0m â”ƒ Táº§ng {u['layer']:3} â”ƒ {exp_str:>9} â”ƒ\n"
            
        desc += "\u001b[1;33mâ”—â”â”â”â”â”»â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”»â”â”â”â”â”â”â”â”â”â”â”â”»â”â”â”â”â”â”â”â”â”â”â”â”›\u001b[0m\n"
        desc += "```"
            
        embed = txa_embed("ğŸ“Š ThiÃªn Lam Tu Vi Báº£ng", desc or "ChÆ° thiÃªn chÆ°a cÃ³ ai ghi danh!", Color.gold())
        embed.set_thumbnail(url="https://hoathinh3d.moi/wp-content/uploads/2023/02/luyen-khi-10-van-nam-300x450.jpg")
        embed.add_field(name="âœ¨ PhÃ¡p Táº¯c", value="Äáº¡o há»¯u cÃ³ tu vi thÃ¢m háº­u nháº¥t sáº½ Ä‘á»©ng Ä‘áº§u thiÃªn báº£ng.", inline=False)
        embed.set_footer(text="Tháº§n báº£ng phong vÃ¢n - ThiÃªn Lam TÃ´ng.")
        await interaction.followup.send(embed=embed, ephemeral=True)

    def get_active_inventory(self, user):
        """Láº¥y danh sÃ¡ch váº­t pháº©m cÃ³ thá»ƒ sá»­ dá»¥ng (trong kho) hoáº·c Ä‘ang kÃ­ch hoáº¡t (buff)"""
        inv = user.get('inventory', [])
        now = time.time()
        # Giá»¯ láº¡i náº¿u cÃ²n sá»‘ lÆ°á»£ng (chÆ°a dÃ¹ng) HOáº¶C cÃ²n thá»i háº¡n (Ä‘ang buff)
        active_inv = [it for it in inv if it.get('count', 0) > 0 or it.get('expiry', 0) > now]
        return active_inv

    async def ensure_active_inventory(self, uid, user):
        """Kiá»ƒm tra vÃ  dá»n dáº¹p váº­t pháº©m háº¿t háº¡n hoáº·c Ä‘Ã£ dÃ¹ng háº¿t trong DB"""
        inv = user.get('inventory', [])
        now = time.time()
        new_inv = []
        changed = False
        
        for it in inv:
            count = it.get('count', 0)
            expiry = it.get('expiry', 0)
            
            # Náº¿u cÃ²n sá»‘ lÆ°á»£ng hoáº·c chÆ°a háº¿t háº¡n thÃ¬ giá»¯ láº¡i
            if count > 0 or expiry > now:
                # Náº¿u Ä‘Ã£ háº¿t háº¡n nhÆ°ng váº«n cÃ²n trong list (do cÃ²n count), reset expiry vá» 0 Ä‘á»ƒ clean
                if expiry > 0 and expiry <= now:
                    it['expiry'] = 0
                    changed = True
                new_inv.append(it)
            else:
                changed = True
        
        if changed:
            await self.db.update_user(uid, inventory=new_inv)
            user['inventory'] = new_inv
            rainbow_log(f"ğŸ§¹ [Inventory] ÄÃ£ dá»n dáº¹p váº­t pháº©m háº¿t háº¡n/háº¿t sá»‘ lÆ°á»£ng cá»§a {user['name']}.")
        return new_inv

    @app_commands.command(name="inventory", description="Xem tÃºi tháº§n thÃ´ng (Cáº­p nháº­t Real-time & Háº¡n dÃ¹ng)")
    async def inventory(self, interaction: discord.Interaction):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start` Ä‘á»ƒ nhÃ¬n tháº¥u tÃºi tháº§n thÃ´ng.", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
            
        msg = await interaction.response.send_message("ğŸŒ€ Äang kiá»ƒm váº­t trong tÃºi...", ephemeral=True)
        
        start_time = time.time()
        while time.time() - start_time < 120:
            user = await self.db.get_user(uid)
            if not user: break
            
            now = time.time()
            # Dá»n dáº¹p real-time
            inv = await self.ensure_active_inventory(uid, user)
            
            if not inv:
                content = "Trá»‘ng trÆ¡n, khÃ´ng cÃ³ má»™t viÃªn linh tháº¡ch hay phÃ¡p báº£o nÃ o."
            else:
                content = ""
                for item in inv:
                    item_data = CultivationData.ITEMS.get(item['id'], {"name": "VÃ´ Danh", "emoji": "â“"})
                    count = item.get('count', 0)
                    expiry = item.get('expiry', 0)
                    
                    parts = []
                    if count > 0:
                        parts.append(f"ğŸ“¦ Trong kho: **x{count}**")
                    if expiry > now:
                        rem = int(expiry - now)
                        parts.append(f"âœ¨ Äang kÃ­ch hoáº¡t: `{TXAFormat.duration_detail(rem)}`")
                    
                    content += f"{item_data['emoji']} **{item_data['name']}**\nâ”” { ' | '.join(parts) if parts else 'ÄÃ£ cáº¡n kiá»‡t'}\n"
            
            embed = txa_embed("ğŸ‘‹ TÃºi Tháº§n ThÃ´ng", content, discord.Color.blue())
            embed.set_footer(text=f"Linh Tháº¡ch: {user['spirit_stones']} ğŸ’ | Tá»± há»§y sau 2 phÃºt")
            
            try: await interaction.edit_original_response(content=None, embed=embed)
            except: break
            await asyncio.sleep(5)
            
        try: await interaction.delete_original_response()
        except: pass

    @app_commands.command(name="shop", description="Váº¡n Báº£o CÃ¡c - Xem danh sÃ¡ch báº£o váº­t")
    async def shop(self, interaction: discord.Interaction):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start` Ä‘á»ƒ vÃ o Váº¡n Báº£o CÃ¡c.", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
            
        embed = txa_embed("â›©ï¸ Váº N Báº¢O CÃC", "NÆ¡i quy tá»¥ ká»³ trÃ¢n dá»‹ báº£o trong thiÃªn háº¡.", discord.Color.purple())
        for item_id, info in CultivationData.ITEMS.items():
            dur_str = TXAFormat.duration_detail(info.get('duration', 0))
            embed.add_field(name=f"{info['emoji']} {info['name']} - ğŸ’° {info['price']}", value=f"{info['desc']}\n*Thá»i háº¡n: {dur_str}*", inline=False)
        embed.set_footer(text="Sá»­ dá»¥ng /buy Ä‘á»ƒ mua váº­t pháº©m.")
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @app_commands.command(name="buy", description="Mua váº­t pháº©m tá»« Váº¡n Báº£o CÃ¡c")
    @app_commands.describe(item_id="Chá»n váº­t pháº©m muá»‘n mua")
    async def buy(self, interaction: discord.Interaction, item_id: str):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user: return await interaction.response.send_message("âŒ ChÆ°a nháº­p mÃ´n!", ephemeral=True)
        
        if item_id not in CultivationData.ITEMS:
            return await interaction.response.send_message("âŒ Váº­t pháº©m khÃ´ng tá»“n táº¡i!", ephemeral=True)
            
        info = CultivationData.ITEMS[item_id]
        if user['spirit_stones'] < info['price']:
            return await interaction.response.send_message(f"âŒ Cáº§n thÃªm {info['price'] - user['spirit_stones']} ğŸ’ Ä‘á»ƒ mua!", ephemeral=True)
            
        # Dá»n dáº¹p Ä‘á»“ háº¿t háº¡n trÆ°á»›c
        inv = await self.ensure_active_inventory(uid, user)
        found = False
        for item in inv:
            if item['id'] == item_id:
                item['count'] = item.get('count', 0) + 1
                found = True
                break
        if not found:
            inv.append({"id": item_id, "count": 1, "expiry": 0})
        
        await self.db.update_user(uid, spirit_stones=user['spirit_stones'] - info['price'], inventory=inv)
        rainbow_log(f"ğŸ›’ [Shop] {user['name']} Ä‘Ã£ mua {info['name']}, váº­t pháº©m Ä‘Ã£ vÃ o tÃºi.")
        await interaction.response.send_message(f"âœ… ÄÃ£ mua thÃ nh cÃ´ng **{info['emoji']} {info['name']}**! Váº­t pháº©m Ä‘Ã£ Ä‘Æ°á»£c cáº¥t vÃ o tÃºi tháº§n thÃ´ng. HÃ£y dÃ¹ng `/use_item` Ä‘á»ƒ kÃ­ch hoáº¡t.", ephemeral=True)

    @buy.autocomplete("item_id")
    async def buy_autocomplete(self, interaction: discord.Interaction, current: str):
        user = await self.db.get_user(str(interaction.user.id))
        if not user: return []
        
        choices = []
        for iid, info in CultivationData.ITEMS.items():
            if current.lower() in info['name'].lower():
                # Hiá»ƒn thá»‹ dáº¥u âœ… náº¿u Ä‘á»§ tiá»n, âŒ náº¿u khÃ´ng Ä‘á»§
                prefix = "âœ…" if user['spirit_stones'] >= info['price'] else "âŒ"
                choices.append(app_commands.Choice(name=f"{prefix} {info['name']} ({info['price']} ğŸ’)", value=iid))
        return choices[:25]

    @app_commands.command(name="use_item", description="Sá»­ dá»¥ng váº­t pháº©m trong tÃºi")
    @app_commands.describe(item_id="Chá»n váº­t pháº©m muá»‘n dÃ¹ng")
    async def use_item(self, interaction: discord.Interaction, item_id: str):
        uid = str(interaction.user.id)
        user = await self.db.get_user(uid)
        if not user:
            embed = txa_embed("â›©ï¸ ThiÃªn Lam Cáº¥m Cháº¿", "NgÆ°Æ¡i chÆ°a ghi danh! HÃ£y dÃ¹ng `/start` Ä‘á»ƒ sá»­ dá»¥ng phÃ¡p báº£o.", discord.Color.red())
            return await interaction.response.send_message(embed=embed, ephemeral=True)
        
        # Lá»c Ä‘á»“ háº¿t háº¡n
        inv = await self.ensure_active_inventory(uid, user)
        item_idx = -1
        for i, it in enumerate(inv):
            if it['id'] == item_id and it.get('count', 0) > 0:
                item_idx = i
                break
                
        if item_idx == -1:
            return await interaction.response.send_message("âŒ NgÆ°Æ¡i khÃ´ng cÃ³ váº­t pháº©m nÃ y!", ephemeral=True)
            
        item_info = CultivationData.ITEMS.get(item_id)
        if not item_info: return
        
        # 1. Trá»« sá»‘ lÆ°á»£ng trong kho
        inv[item_idx]['count'] -= 1
        now = time.time()
        
        # 2. Xá»­ lÃ½ thá»i háº¡n (Buff)
        duration = item_info.get('duration', 0)
        has_buff = False
        if duration > 0:
            # Cá»™ng dá»“n thá»i gian náº¿u Ä‘ang cÃ³ buff active, náº¿u khÃ´ng thÃ¬ tÃ­nh tá»« now
            inv[item_idx]['expiry'] = max(inv[item_idx].get('expiry', 0), now) + duration
            has_buff = True
            
        # 3. Xá»­ lÃ½ hiá»‡u á»©ng tá»©c thÃ¬ (EXP)
        effect = item_info.get('effect', {})
        exp_gain = effect.get('exp', 0)
        leveled_up = False
        new_layer = user['layer']
        new_goal = user['goal']
        new_exp = user['exp']
        
        if exp_gain > 0:
            new_exp += exp_gain
            while new_exp >= new_goal:
                new_exp -= new_goal
                new_layer += 1
                new_goal = max(new_layer * 1000, 200)
                leveled_up = True
                
        # LÆ°u thay Ä‘á»•i
        await self.db.update_user(uid, exp=new_exp, layer=new_layer, goal=new_goal, inventory=inv)
        
        # ThÃ´ng bÃ¡o
        desc = f"NgÆ°Æ¡i Ä‘Ã£ sá»­ dá»¥ng **{item_info['emoji']} {item_info['name']}**.\n"
        if exp_gain > 0:
            desc += f"ğŸ“ˆ Nháº­n Ä‘Æ°á»£c: **{exp_gain} EXP** linh lá»±c.\n"
        if has_buff:
            dur_str = TXAFormat.duration_detail(duration)
            desc += f"âœ¨ KÃ­ch hoáº¡t Buff: **+{dur_str}** vÃ o thá»i háº¡n sá»­ dá»¥ng.\n"
        
        embed = txa_embed("âœ¨ Sá»­ Dá»¥ng Váº­t Pháº©m", desc, discord.Color.green())
        if leveled_up: 
            embed.add_field(name="ğŸ”¥ Äá»˜T PHÃ", value=f"NgÆ°Æ¡i Ä‘Ã£ tiáº¿n tá»›i **Táº§ng {new_layer}**!")
            await self.check_auto_role(interaction.user, new_layer)
            
        rainbow_log(f"ğŸ’Š [Item] {user['name']} Ä‘Ã£ dÃ¹ng {item_info['name']}.")
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @use_item.autocomplete("item_id")
    async def use_item_autocomplete(self, interaction: discord.Interaction, current: str):
        user = await self.db.get_user(str(interaction.user.id))
        if not user: return []
        
        # Chá»‰ hiá»ƒn thá»‹ Ä‘á»“ cÃ²n háº¡n
        inv = self.get_active_inventory(user)
        
        choices = []
        for it in inv:
            # Chá»‰ cho phÃ©p chá»n váº­t pháº©m cÃ²n sá»‘ lÆ°á»£ng trong kho
            if it.get('count', 0) <= 0: continue
            
            info = CultivationData.ITEMS.get(it['id'])
            if info and current.lower() in info['name'].lower():
                choices.append(app_commands.Choice(name=f"{info['emoji']} {info['name']} (x{it['count']})", value=it['id']))
        return choices[:25]

    @app_commands.command(name="thach_dau", description="Giao Ä‘áº¥u tu tiÃªn - AI TÆ°á»ng thuáº­t")
    async def thach_dau(self, interaction: discord.Interaction, user: discord.Member):
        if user.id == interaction.user.id: 
            return await interaction.response.send_message("âŒ Tu vi cá»§a ngÆ°Æ¡i chÆ°a Ä‘á»§ Ä‘á»ƒ phÃ¢n thÃ¢n tá»± Ä‘áº¥u!", ephemeral=True)
            
        p1_data = await self.db.get_user(str(interaction.user.id))
        p2_data = await self.db.get_user(str(user.id))
        
        if not p1_data or not p2_data:
            return await interaction.response.send_message("âŒ Má»™t trong hai Ä‘áº¡o há»¯u chÆ°a bÆ°á»›c vÃ o con Ä‘Æ°á»ng tu Ä‘áº¡o!", ephemeral=True)
            
        # Check if users are busy
        if interaction.user.id in self.battling_users:
            return await interaction.response.send_message("âŒ NgÆ°Æ¡i Ä‘ang trong má»™t tráº­n Ä‘áº¥u phÃ¡p khÃ¡c!", ephemeral=True)
        if user.id in self.battling_users:
            return await interaction.response.send_message(f"âŒ {user.display_name} Ä‘ang báº­n Ä‘áº¥u phÃ¡p vá»›i ngÆ°á»i khÃ¡c!", ephemeral=True)
            
        # Lock users
        self.battling_users.add(interaction.user.id)
        self.battling_users.add(user.id)
        
        try:
            # DM Notification
            try:
                channel_link = f"https://discord.com/channels/{interaction.guild.id}/{interaction.channel.id}"
                embed_dm = txa_embed(
                    "âš”ï¸ Lá»œI TUYÃŠN CHIáº¾N",
                    f"**{interaction.user.display_name}** Ä‘Ã£ gá»­i lá»i thÃ¡ch Ä‘áº¥u Ä‘áº¿n ngÆ°Æ¡i táº¡i **#{interaction.channel.name}**!\n\nğŸ‘‰ [Nháº¥n vÃ o Ä‘Ã¢y Ä‘á»ƒ Ä‘áº¿n Äáº¥u PhÃ¡p ÄÃ i]({channel_link})",
                    discord.Color.red()
                )
                await user.send(embed=embed_dm)
            except: 
                rainbow_log(f"âš ï¸ KhÃ´ng thá»ƒ gá»­i DM thÃ¡ch Ä‘áº¥u cho {user.name}")
            
            rainbow_log(f"âš”ï¸ [Combat] {interaction.user.name} thÃ¡ch Ä‘áº¥u {user.name}")
            combat = CombatSystem(self.bot, interaction.user, user, p1_data, p2_data)
            await combat.start_battle(interaction)
            
        except Exception as e:
            rainbow_log(f"âŒ Lá»—i Combat: {e}")
            await interaction.followup.send(f"âš ï¸ Tráº­n Ä‘áº¥u bá»‹ giÃ¡n Ä‘oáº¡n do lá»—i thiÃªn Ä‘áº¡o: {e}", ephemeral=True)
        finally:
            # Release lock
            if interaction.user.id in self.battling_users: self.battling_users.remove(interaction.user.id)
            if user.id in self.battling_users: self.battling_users.remove(user.id)

async def setup(bot):
    await bot.add_cog(Cultivation(bot))
